<p>La variable que acabamos de crear nada más que podrá contener el valor que le hemos asignado, es decir 'Hola'.</p>
<pre><code [highlight]="code"></code></pre>
<p>Por si solo no tiene una gran utilidad por lo que se combina con union types, type guards, y type alias. Los cuales explicaremos más tarde.</p>
<pre><code [highlight]="code"></code></pre>
<h2>Array</h2>
<p>Arrays, sino se les especifica tipo son <b>ANY</b></p>
<pre><code [highlight]="code"></code></pre>
<p>Con esta sintaxis se puede especificar qué tipo de datos debe haber en el array</p>
<pre><code [highlight]="code"></code></pre>
<h2>Null</h2>
<p>Es cuando un objeto o variable no esta accesible.</p>
<h2>Undefined</h2>
<p>Es cuando un objeto o variabe existe pero no tiene un valor. Si nuestro código interactua con alguna API podemos recibir null como respuesta, para evaluar esas respuestas es mejor utilizar <code class="code-text">==</code> en vez de <code class="code-text">===</code></p>
<pre><code [highlight]="code"></code></pre>
<h2>Tuple / Tuplas</h2>
<p>Como en base de datos, hacen referencia a registros clave / valor</p>
<pre><code [highlight]="code"></code></pre>
<p>Para acceder a los datos dentro de las tuplas de las cuales sabes el índice se hace así:</p>
<pre><code [highlight]="code"></code></pre>
<p>Cuando queramos acceder a un elemento sin conocer el mapeo del contenido</p>
<pre><code [highlight]="code"></code></pre>
<h2>Enum</h2>
<p>Los enumerado en <b>TypeScript</b>, son distintos a los enumerados de otros lenguajes de programación, estos solo almacenan números para identificar las constantes.</p>
<p>Si no se le especifica el valor por defecto se lo asigna normalmente, también es importante saber, que los enumerados no aceptan que su valor sea un String, solamente número</p>
<pre><code [highlight]="code"></code></pre>
<p>Sin asignación de valor</p>
<pre><code [highlight]="code"></code></pre>
<p>Con asignación de valor</p>
<pre><code [highlight]="code"></code></pre>
<p>También se puede acceder al nombre de los atributos</p>
Para comprobar lo que digo utilizaré Type alias, y el ejemplo es el siguinte:
<p>Es muy importante saber que distintos enumerados no pueden ser comparados ya que el nombre de los enumerados no es el mimo, aunque puedan tener el mismo indice númerico.</p>
<p>Para comprobar lo que digo utilizaré Type alias, y el ejemplo es el siguinte:</p>
<pre><code [highlight]="code"></code></pre>
<h2>Any</h2>
<p>Puede ser cualquier tipo de objeto de javascript</p>
<pre><code [highlight]="code"></code></pre>
<h2>Void</h2>
<pre><code [highlight]="code"></code></pre>
<p>Este tipo de dato no es recomendable para variables ya que solo pueden ser asignados valores null o undefined</p>
<pre><code [highlight]="code"></code></pre>
<h2>Let</h2>
<p>En javascript hay dos formas de declarar variables: <code class="code-text">var</code> y <code class="code-text">let</code>, var no tiene un ámbito de bloque mientras que <code class="code-text">let</code> sí.</p>
<code class="code-blockquotes">var</code>
<pre><code [highlight]="code"></code></pre>
<code class="code-blockquotes">let</code>
<pre><code [highlight]="code"></code></pre>
<h2>Const</h2>
<p>Ha sido añadido en ES6 / TypeScript permitiendonos añadir variables inmutables tanbien conocidas como constantes. El uso de <code class="code-text">const</code> es una buena práctica de mantenimiento y legibilidad. <b>Las constantes deben ser declaradas y asignadas siempre</b>.</p>
<pre><code [highlight]="code"></code></pre>
<p>Las constantes también admiten objetos literales como por ejemplo:</p>
<pre><code [highlight]="code"></code></pre>
<p>Pero si se puede modificar el contenido de las variables que contiene el objeto literal, ejemplo:</p>
<pre><code [highlight]="code"></code></pre>
<h2>For in</h2>
<p>For in es una característica que ya tenia javascript ,y no ha sido mejorada en TypeScript, mediante la cual puedes acceder y recorrer objetos y arrays y obtener tanto los índices como los valores.</p>
<p>For in accediendo al valor de una variable dentro de un objeto:</p>
<code class="code-blockquotes"><b>TypeScript</b></code>
<pre><code [highlight]="code"></code></pre>
<code class="code-blockquotes"><b>Javascript</b></code>
<pre><code [highlight]="code"></code></pre>
<p><code class="code-text">For in</code> accediendo al índice de una variable dentro de un objeto;</p>
<code class="code-blockquotes"><b>TypeScript</b></code>
<pre><code [highlight]="code"></code></pre>
<code class="code-blockquotes"><b>Javascript</b></code>
<pre><code [highlight]="code"></code></pre>
<h2>For of</h2>
<p><code class="code-text">For of</code> es una característica nueva de ES6 con la <b>cual puedes acceder y recorrer arrays y strings obteniendo su valor</b>, es decir, no puede recorrer objetos. Aunque se podrían recorrer objetos en el caso de que estos fueran creados por clases que implementen <code class="code-text">Symbol.iterator</code> . <code class="code-text">for ... of</code> también tiene un peor rendimiento en comparación con el <code class="code-text">for...in</code> ya que al compilarlo a JS crea más variables y hace más comprobaciones.</p>
<p>For of accediendo al valor de una variable dentro de un array:</p>
<code class="code-blockquotes"><b>TypeScript</b></code>
<pre><code [highlight]="code"></code></pre>
<code class="code-blockquotes"><b>Javascript</b></code>
<pre><code [highlight]="code"></code></pre>
<p>For of accediendo al valor de una variable dentro de un string:</p>
<code class="code-blockquotes"><b>TypeScript</b></code>
<pre><code [highlight]="code"></code></pre>
<code class="code-blockquotes"><b>Javascript</b></code>
<pre><code [highlight]="code"></code></pre>
<p>For of accediendo al valor de una variable dentro de un objeto, el cual nos dará error:</p>
<code class="code-blockquotes"><b>TypeScript</b></code>
<pre><code [highlight]="code"></code></pre>
<code class="code-blockquotes"><b>Javascript</b></code>
<pre><code [highlight]="code"></code></pre>
<p>El error según el transpilador de <b>TypeScript</b> Es el siguiente:</p>
<img src="assets/../img1.png" alt="img">
<h2>Funciones</h2>
<p>Este tipo de función hace referencia al objeto que llama a esta función</p>
<pre><code [highlight]="code"></code></pre>
<p>Este tipo de funciones, lo que hacen es que el this no hace referencia al padre sino al objeto que contiene la función</p>
<pre><code [highlight]="code"></code></pre>
<p>Ejemplos sobre como evitar el tipo Any y filtrar solo por los tipos de datos que necesitamos</p>
<pre><code [highlight]="code"></code></pre>
<p><b>TypeScript</b> admite que se declaren parametros opcionales de la siguiente forma utilizando la <code class="code-text">?</code>:</p>
<pre><code [highlight]="code"></code></pre>
<h2>Igualación de funciones</h2>
<p>En javascript las funciones pueden ser igualadas, <b>TypeScript</b> junto con su nueva sintáxis también permite este comportamiento como por ejemplo, utilizando las <b>fat arrow</b>:</p>
<pre><code [highlight]="code"></code></pre>
<pre><code [highlight]="code"></code></pre>
<h2>Genéricos</h2>
<p>Los tipos genéricos, son aquellos que como las interfaces no se verán compilados en Javascript ya que solo están accesibles en tiempo de compilación, La manera adecuada de realizar la sobrecarga de métodos es con los tipos genéricos un ejemplo sería así:</p>
<code class="code-blockquotes">Versión TypeScript</code>
<pre><code [highlight]="code"></code></pre>
<p>La diferencia entre esta forma y la otra, es que de esta forma, podríamos recibir cualquier tipo de objeto, y no deberíamos especificar el tipo de objeto que esperamos, esto esta muy bien ya que está diseñado para los objetos que no son primitivos de javascript. Con esto evitamos el <b>Any</b> y mejoraría la manera de realizar la sobrecarga (Lejos de como sería en Java o C#).</p>
<p>Con los tipos genéricos se debe tener cuidado, ya que no todos los métodos estan disponibles para todos lo tipos de objetos.</p>
<code class="code-blockquotes">TypeScript</code>
<pre><code [highlight]="code"></code></pre>
<code class="code-blockquotes">Javascript</code>
<pre><code [highlight]="code"></code></pre>
<p>Como se puede apreciar en este ejemplo podemos declarar una función dentro de una clase que devolverá lo que le pasemos por parametro, permitiendonos así modificar los returns de nuestras funciones según queramos.</p>
<p>Para poder pasar como parametro a una función y asegurarnos de que ese parámetro tiene un método en concreto deberemos implementar una interfaz y forzar al parámetro que se le pasará a la función a utilizar dicha interfaz.</p>
<code class="code-blockquotes">TypeScript Nota: Es muy importante que veaís que cuando se implementa una interfaz en un parámetro utilizamos la palabra reservada <b>extends</b> y no la palabra reservada <b>implements</b></code>
<pre><code [highlight]="code"></code></pre>
<code class="code-blockquotes">Javascript</code>
<pre><code [highlight]="code"></code></pre>
<p>También podemos hacer que los atributos que intentamos modificar se encuentren dentro del tipo de objeto que le pasa, eso sería de la siguiente forma.</p>
<pre><code [highlight]="code"></code></pre>
<h2>Aserción de tipos (Assert)</h2>
<pre><code [highlight]="code"></code></pre>
<p>Y si ahora añadieramos una clase más este condicional no controlaria esa situación, en este ejemplo al ser tan simple se ve claro, pero en clases más complejas con lógicas más complejas puede llegar ha ser un gran problema.</p>
<h2>Type Alias</h2>
<p>Los <b>Type Alias</b> son exactamente los mismos tipos dedatos y valores originales solo que con nombres alternativos, esto sirve para darle más semántica al lenguaje.</p>
<p>ype alias utiliza la palabra reservada <code class="code-text">type</code> para funcionar:</p>
<pre><code [highlight]="code"></code></pre>
<p>los <b>Type alias</b> no solo pueden ser tipos de datos generícos, también se pueden utilizar parametros como por ejemplo:</p>
<pre><code [highlight]="code"></code></pre>
<p>También puede hacer referencia a sí mismo:</p>
<pre><code [highlight]="code"></code></pre>
<p>El operador <code class="code-text">&</code> se utiliza para crear un tipo de dato base como por ejemplo:</p>
<pre><code [highlight]="code"></code></pre>
<h2>Type Union</h2>
<p>Implica que solo los métodos que sean iguales de ambas interfaces o clases (solamente el nombre del método sean iguales, el contenido puede ser distinto) podrán ser utilizados allí donde se utilicen métodos de unión como el siguiente ejemplo:</p>
<pre><code [highlight]="code"></code></pre>
<h2>Type Guards</h2>
<p>Son las maneras de controlar los tipos de datos\/objetos que se están utilizando, esto rompe con la programación orientada a objetos ya que esto representa un problema para el polimorfismo, por ejemplo: si estuvieramos haciendo una serie de comprobaciones para que según el tipo de clase u objeto se realize una acción u otra en el momento en el que existiera un objeto o clase que no tuvieramos contemplado tendriamos que modificar todo el código.</p>
<pre><code [highlight]="code"></code></pre>
<h2>Fat arrow</h2>
<p>Las funciones <b>fat arrow</b> se utilizan en para:</p>
<ul>
  <li>
    Omitir la palabrá <code class="code-text">function</code>
    <pre><code [highlight]="code"></code></pre>
  </li>
  <li>
    Para capturar el <code class="code-text">this</code> , ya que en javascript se pierde muy rapidamente el contexto de <code class="code-text">this</code> como por ejemplo en la siguiente situación:
    <pre><code [highlight]="code"></code></pre>
    <p>Esto es debido a que el <code class="code-text">this</code> que ejecuta la función <code class="code-text">growOld</code> en javascrirpt es <code class="code-text">window</code> y no <code class="code-text">Person</code>. Si utilizaramos una función con fat arrow funciona, esta funcionaría.</p>
    <pre><code [highlight]="code"></code></pre>
    <p>Otra solución sería mezclar las 2 sintaxis</p>
    <pre><code [highlight]="code"></code></pre>
  </li>
  <li>Para capturar argumentos</li>
</ul>
<h2>¿Cuándo es necesario utilizar una fat arrow?</h2>
<p>Es necesario utilizarla cuando la función va ha ser llamada por otra clase o por otro método de la siguiente forma:</p>
<pre><code [highlight]="code"></code></pre>
<h2>Como utilizarlas con librerías que utilizan <code class="code-text">this</code></h2>
<p>Existen muchas librerías como por ejemplo jQuery, para trabajar con este tipo de librerías utilizamos variables auxiliares como por ejemplo <code class="code-text">_self</code></p>
<pre><code [highlight]="code"></code></pre>
<h2>¿Cómo utilizar funciones con herencia?</h2>
<p>En caso de que quieras sobreescribir una función de la clase padre siempre deberemos realizar una copia de este, por ejemplo:</p>
<pre><code [highlight]="code"></code></pre>
<h2>Cadenas de fat arrow (Currying)</h2>
<p>Es una seríe de funciones encadenadas el uso es simple y es el siguiente:</p>
<pre><code [highlight]="code"></code></pre>
<h2>Desestructuración</h2>
<p>La desestructuración nos permite extraer valores almacenados en arrays u objetos.</p>
<code class="code-blockquotes">Desestructuración de objetos</code>
<pre><code [highlight]="code"></code></pre>
<code class="code-blockquotes">Desestructuración de arrays</code>
<pre><code [highlight]="code"></code></pre>
<code class="code-blockquotes">Desestructuración de arrays con estructuración</code>
<pre><code [highlight]="code"></code></pre>
<h2>Estructuración</h2>
<p>La estructuración de parámetros es una forma rápida de que por ejemplo una función acepte una gran cantidad de parámetros como array.</p>
<pre><code [highlight]="code"></code></pre>




<pre><code [highlight]="code"></code></pre>
<code class="code-text"></code>
<code class="code-blockquotes"></code>